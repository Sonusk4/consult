generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        Int             @id @default(autoincrement())
  firebase_uid              String          @unique
  email                     String          @unique
  phone                     String?
  name                      String?  
  role                      String          @default("USER")
  is_verified               Boolean         @default(false)
  otp_code                  String?
  otp_expiry                DateTime?
  invite_token              String?         @unique
  invite_token_expiry       DateTime?
  temp_username             String?
  temp_password             String?
  permanent_username        String?         @unique
  permanent_password        String?
  password_reset_token      String?
  password_reset_expiry     DateTime?
  password_changed          Boolean         @default(false)
  created_at                DateTime        @default(now())
  updated_at                DateTime?       @updatedAt
  bookings                  Booking[]
  consultant                Consultant?
  enterpriseId              Int?
  enterprise                Enterprise?     @relation("EnterpriseMembers", fields: [enterpriseId], references: [id])
  ownedEnterprise           Enterprise?     @relation("EnterpriseOwner")
  messages                  Message[]
  paymentOrders             PaymentOrder[]
  reviews                   Review[]
  supportTickets            SupportTicket[]
  transactions              Transaction[]
  profile                   UserProfile?
  wallet                    Wallet?
  enterpriseBookings        Booking[] @relation("EnterpriseMemberBookings")
}

model UserProfile {
  id               Int      @id @default(autoincrement())
  userId           Int      @unique
  avatar           String?
  bio              String?
  headline         String?
  location         String?
  languages        String?
  expertise        Json?           // Array of expertise/skills
  hourly_rate      Float?
  availability     String?
  designation      String?
  years_experience Int?
  education        String?
  // KYC Fields
  kyc_status       String?         // PENDING, SUBMITTED, APPROVED, REJECTED
  id_proof_url     String?         // URL to ID proof document (PDF/Image)
  address_proof_url String?        // URL to address proof document (PDF/Image)
  kyc_documents    Json?           // Array of additional KYC documents with metadata
  kyc_submitted_at DateTime?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Consultant {
  id             Int             @id @default(autoincrement())
  userId         Int             @unique
  type           String?
  domain         String?
  profile_pic    String?
  hourly_price   Float?
  rating         Float           @default(0)
  total_reviews  Int             @default(0)
  is_verified    Boolean         @default(false)
  
  // Professional Fields
  expertise       Json?           // Array of skills/expertise
  availability    String?         // Full-time, Part-time, Flexible, Weekends
  designation     String?
  years_experience Int?
  education       String?
  
  // KYC Fields
  kyc_status      String          @default("PENDING") // PENDING, SUBMITTED, APPROVED, REJECTED
  kyc_documents   Json?           // Store KYC document URLs and metadata
  
  // Certificate Fields
  certificates    Json?           // Store certificate URLs and metadata

  // Commission Settings (set by admin only, not exposed to consultant or user)
  consultant_commission_pct  Float?   // % deducted from consultant's payout (e.g. 15 means admin keeps 15%)
  user_commission_pct        Float?   // % markup added to user's price (e.g. 10 means user pays +10%)

  availabilitySlots Availability[]
  bookings       Booking[]
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviews        Review[]
  slots          Slot[]
  supportTickets SupportTicket[]
  payouts        ConsultantPayout[]
}

model Availability {
  id             Int        @id @default(autoincrement())
  consultantId   Int
  available_date DateTime
  available_time String
  is_booked      Boolean    @default(false)
  consultant     Consultant @relation(fields: [consultantId], references: [id], onDelete: Cascade)

  @@unique([consultantId, available_date, available_time])
}

model Booking {
  id                Int       @id @default(autoincrement())

  userId            Int
  consultantId      Int?
  enterpriseMemberId Int?

  date              DateTime
  time_slot         String
  status            String    @default("CONFIRMED")
  is_paid           Boolean   @default(false)
  call_completed    Boolean   @default(false)
  call_duration     Int?
  consultant_fee    Float?
  commission_fee    Float?    // platform revenue = (user_price - consultant_net)
  user_commission_fee Float?  // portion of commission charged as markup to user
  net_earning       Float?
  created_at        DateTime  @default(now())
  completed_at      DateTime?

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  consultant        Consultant? @relation(fields: [consultantId], references: [id], onDelete: Cascade)

  enterpriseMember  User?     @relation("EnterpriseMemberBookings", fields: [enterpriseMemberId], references: [id], onDelete: Cascade)

  messages          Message[]
  payment           Payment?
  review            Review?
}
model Message {
  id         Int      @id @default(autoincrement())
  bookingId  Int
  senderId   Int
  content    String
  created_at DateTime @default(now())
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  sender     User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
}

model Payment {
  id          Int      @id @default(autoincrement())
  bookingId   Int      @unique
  amount      Float
  status      String
  razorpay_id String?
  created_at  DateTime @default(now())
  booking     Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
}

model Wallet {
  id         Int      @id @default(autoincrement())
  userId     Int      @unique
  balance    Float    @default(0)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Transaction {
  id             Int      @id @default(autoincrement())
  userId         Int
  type           String
  amount         Float
  description    String?
  bookingId      Int?
  consultantId   Int?
  payment_method String?
  status         String   @default("SUCCESS")
  created_at     DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CreditPackage {
  id         Int      @id @default(autoincrement())
  amount     Float
  bonus      Float    @default(0)
  is_active  Boolean  @default(true)
  created_at DateTime @default(now())
}

model Slot {
  id           String     @id @default(uuid())
  consultantId Int
  date         DateTime
  startTime    String
  endTime      String
  createdAt    DateTime   @default(now())
  consultant   Consultant @relation(fields: [consultantId], references: [id], onDelete: Cascade)
}

model Review {
  id           Int        @id @default(autoincrement())
  bookingId    Int        @unique
  consultantId Int
  userId       Int
  rating       Int
  comment      String?
  created_at   DateTime   @default(now())
  booking      Booking    @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  consultant   Consultant @relation(fields: [consultantId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  consultantReply String?
replied_at      DateTime?
}

model Enterprise {
  id              Int      @id @default(autoincrement())
  name            String
  registration_no String?
  gst_number      String?
  logo            String?
  website         String?
  description     String?
  ownerId         Int      @unique
  created_at      DateTime @default(now())
  priority        String   @default("MEDIUM")
  status          String   @default("OPEN")
  updated_at      DateTime @updatedAt

  owner    User   @relation("EnterpriseOwner", fields: [ownerId], references: [id])
  members  User[] @relation("EnterpriseMembers")

  invites         EnterpriseInvite[]
  supportTickets  SupportTicket[]
}

model PaymentOrder {
  id                  Int      @id @default(autoincrement())
  user_id             Int
  razorpay_order_id   String   @unique
  razorpay_payment_id String?
  razorpay_signature  String?
  amount              Float
  credits             Float
  bonus               Float    @default(0)
  status              String   @default("PENDING")
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt
  user                User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model SupportTicket {
  id           Int         @id @default(autoincrement())
  userId       Int?
  subject      String
  category     String
  description  String
  status       String      @default("OPEN")
  priority     String      @default("MEDIUM")
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  enterpriseId Int?
  consultantId Int?
  consultant   Consultant? @relation(fields: [consultantId], references: [id], onDelete: Cascade)
  enterprise   Enterprise? @relation(fields: [enterpriseId], references: [id], onDelete: Cascade)
  user         User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model EnterpriseInvite {
  id           Int      @id @default(autoincrement())
  email        String
  token        String   @unique
  enterpriseId Int
  status       String   @default("PENDING")
  expiresAt    DateTime
  created_at   DateTime @default(now())

  enterprise Enterprise @relation(fields: [enterpriseId], references: [id], onDelete: Cascade)
}

model Admin {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  password   String
  name       String
  avatar     String?
  role       String   @default("ADMIN")
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model ConsultantPayout {
  id           Int        @id @default(autoincrement())
  consultantId Int
  amount       Float
  status       String     @default("PENDING")  // PENDING | PAID
  paid_at      DateTime?
  notes        String?
  created_at   DateTime   @default(now())
  updated_at   DateTime   @updatedAt
  consultant   Consultant @relation(fields: [consultantId], references: [id], onDelete: Cascade)
}
